"""
Plan Executor - Execute plan with hardcoded search_logs first
"""

import pandas as pd
from typing import Dict, Any, Optional
from .tool_registry import ToolRegistry
from .log_processor import LogProcessor
from ..utils.logger import setup_logger

logger = setup_logger()


class PlanExecutor:
    """
    Execute plans generated by QwenPlanner.
    
    Key features:
    1. ALWAYS runs search_logs first (hardcoded)
    2. Auto-injects logs between tool calls
    3. Tracks cached logs for subsequent operations
    """
    
    def __init__(self, tool_registry: ToolRegistry, log_processor: LogProcessor):
        """
        Initialize executor.
        
        Args:
            tool_registry: Registry with all available tools
            log_processor: LogProcessor for the target log file
        """
        self.registry = tool_registry
        self.log_processor = log_processor
        self.cached_logs: Optional[pd.DataFrame] = None
        
        logger.info("PlanExecutor initialized")
    
    def execute(self, search_value: str, plan: Dict) -> Dict[str, Any]:
        """
        Execute a plan.
        
        Args:
            search_value: Value to search for in logs
            plan: Plan from QwenPlanner {"operations": [...], "params": {...}}
            
        Returns:
            Dictionary of tool_name â†’ ToolResult for each executed tool
        """
        results = {}
        operations = plan.get("operations", [])
        params = plan.get("params", {})
        
        logger.info(f"Executing plan: search_value='{search_value}', operations={operations}")
        
        # Step 1: ALWAYS search_logs first (hardcoded)
        logger.info("Step 1/?: search_logs (hardcoded)")
        search_result = self._execute_search(search_value)
        results["search_logs"] = search_result
        
        if not search_result.success:
            logger.warning(f"Search failed: {search_result.message}")
            return results
        
        # Cache logs for subsequent operations
        self.cached_logs = search_result.data
        log_count = len(self.cached_logs) if self.cached_logs is not None else 0
        logger.info(f"Cached {log_count} logs")
        
        # Step 2+: Execute operations from plan
        for i, op_name in enumerate(operations, start=2):
            logger.info(f"Step {i}/{len(operations)+1}: {op_name}")
            
            # Skip search_logs if LLM included it (shouldn't, but just in case)
            if op_name == "search_logs":
                logger.info("Skipping search_logs (already done)")
                continue
            
            result = self._execute_operation(op_name, params)
            results[op_name] = result
            
            if not result.success:
                logger.warning(f"Operation {op_name} failed: {result.message}")
                # Continue anyway - some operations may still work
            
            # Update cached logs if this was a filter operation
            if op_name.startswith("filter_") and result.success and result.data is not None:
                if isinstance(result.data, pd.DataFrame):
                    self.cached_logs = result.data
                    logger.info(f"Updated cache: {len(self.cached_logs)} logs after {op_name}")
        
        return results
    
    def _execute_search(self, search_value: str):
        """Execute search_logs tool."""
        tool = self.registry.get("search_logs")
        if not tool:
            from .tools.base_tool import ToolResult
            return ToolResult(
                success=False,
                data=None,
                message="search_logs tool not found"
            )
        
        # If search_value is empty, get all logs
        if search_value:
            return tool.execute(value=search_value)
        else:
            return tool.execute(value="")
    
    def _execute_operation(self, op_name: str, all_params: Dict):
        """Execute a single operation with appropriate params."""
        from .tools.base_tool import ToolResult
        
        tool = self.registry.get(op_name)
        if not tool:
            return ToolResult(
                success=False,
                data=None,
                message=f"Unknown tool: {op_name}"
            )
        
        # Build params for this specific tool
        tool_params = self._build_tool_params(op_name, all_params)
        
        # Auto-inject logs if tool needs them
        if self._tool_needs_logs(tool) and self.cached_logs is not None:
            tool_params["logs"] = self.cached_logs
        
        try:
            return tool.execute(**tool_params)
        except Exception as e:
            logger.error(f"Tool {op_name} execution failed: {e}")
            return ToolResult(
                success=False,
                data=None,
                message=f"Execution error: {str(e)}"
            )
    
    def _build_tool_params(self, op_name: str, all_params: Dict) -> Dict:
        """Extract relevant params for a specific tool."""
        # Parameter mapping: which params each tool uses
        param_mapping = {
            "filter_by_time": ["start_time", "end_time"],
            "filter_by_severity": ["severities"],
            "filter_by_field": ["field", "value"],
            "extract_entities": ["entity_types"],
            "count_entities": ["entity_type"],
            "aggregate_entities": ["entity_types"],
            "find_entity_relationships": ["target_value", "related_types"],
            "return_logs": ["max_samples"],
            "get_log_count": [],
            "normalize_term": ["term"],
            "fuzzy_search": ["term", "field"],
        }
        
        relevant_keys = param_mapping.get(op_name, [])
        return {k: v for k, v in all_params.items() if k in relevant_keys}
    
    def _tool_needs_logs(self, tool) -> bool:
        """Check if tool has a 'logs' parameter."""
        for param in tool.parameters:
            if param.name == "logs":
                return True
        return False
    
    def get_cached_logs(self) -> Optional[pd.DataFrame]:
        """Get currently cached logs."""
        return self.cached_logs

